// Mock API Service for development without backend
import { v4 as uuidv4 } from 'uuid';
import { logger } from '../../utils/errorHandling';

// Simulated delay to emulate network latency
const MOCK_DELAY = parseInt(import.meta.env.VITE_MOCK_DELAY || '300');

interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: string;
}

// Mock data
const mockProjects = [
  {
    id: 'proj_' + Math.random().toString(36).substr(2, 9),
    name: 'E-commerce Platform',
    description: 'Full-stack e-commerce application',
    framework: 'React',
    status: 'active',
    environment: 'development',
    deployments: [],
    lastModified: '2 hours ago',
    createdAt: new Date()
  },
  {
    id: 'proj_' + Math.random().toString(36).substr(2, 9),
    name: 'Personal Blog',
    description: 'A simple blog built with Next.js',
    framework: 'Next.js',
    status: 'active',
    environment: 'development',
    deployments: [],
    lastModified: '1 day ago',
    createdAt: new Date()
  }
];

const mockProviders = [
  {
    id: 'openai',
    name: 'OpenAI',
    type: 'openai',
    status: 'connected',
    models: [
      {
        id: 'gpt-4',
        name: 'GPT-4',
        displayName: 'GPT-4',
        maxTokens: 8192,
        inputCost: 0.03,
        outputCost: 0.06,
        capabilities: [
          { type: 'code-generation', supported: true },
          { type: 'code-analysis', supported: true },
          { type: 'chat', supported: true },
          { type: 'function-calling', supported: true }
        ]
      }
    ]
  }
];

class MockApiService {
  // Projects API
  async getProjects(): Promise<ApiResponse<any[]>> {
    await this.delay();
    logger.info('MockApiService: Getting projects');
    return {
      success: true,
      data: mockProjects
    };
  }

  async getProject(id: string): Promise<ApiResponse> {
    await this.delay();
    const project = mockProjects.find(p => p.id === id);
    
    if (!project) {
      return {
        success: false,
        error: 'Project not found',
        status: 404
      };
    }
    logger.info(`MockApiService: Getting project ${id}`);
    return {
      success: true,
      data: project
    };
  }

  async createProject(data: { name: string, description: string, framework?: string }): Promise<ApiResponse> {
    await this.delay();
    
    const newProject = {
      id: 'proj_' + Math.random().toString(36).substr(2, 9),
      name: data.name,
      description: data.description,
      framework: data.framework || 'React',
      status: 'active',
      environment: 'development',
      deployments: [],
      lastModified: 'just now',
      createdAt: new Date()
    };
    
    mockProjects.push(newProject);
    logger.info(`MockApiService: Created new project ${newProject.id}`);
    return {
      success: true,
      data: newProject
    };
  }

  // AI API
  async getAIModels(): Promise<ApiResponse<any>> {
    await this.delay();
    logger.info('MockApiService: Getting AI models');
    
    // Return in the format expected by the app, with providers in a separate property
    return {
      success: true,
      data: {
        providers: mockProviders,
        defaultProvider: 'openai',
        defaultModel: 'gpt-3.5-turbo'
      }
    };
  }

  async chatCompletion(data: any): Promise<ApiResponse> {
    await this.delay(800);
    logger.info(`MockApiService: Chat completion with model ${data.model}`);
    
    return {
      success: true,
      data: {
        content: "I can help you with that! This is a mock response from the development service. In production, you would get a real AI response.",
        usage: {
          prompt_tokens: 100,
          completion_tokens: 50,
          total_tokens: 150
        },
        model: data.model,
        provider: data.provider,
        metadata: {
          sessionId: data.sessionId,
          timestamp: new Date().toISOString()
        }
      }
    };
  }

  async generateCode(data: { prompt: string, language: string }): Promise<ApiResponse> {
    await this.delay(1000);
    logger.info(`MockApiService: Generating code in ${data.language}`);
    
    return {
      success: true,
      data: {
        code: `// Generated code for: ${data.prompt}\nfunction example() {\n  console.log("Hello world");\n  return true;\n}`,
        language: data.language,
        explanation: "This is a sample implementation generated by the mock AI service."
      }
    };
  }

  async analyzeCode(data: { code: string, language: string }): Promise<ApiResponse> {
    await this.delay(1200);
    logger.info(`MockApiService: Analyzing ${data.language} code`);
    
    return {
      success: true,
      data: {
        suggestions: [
          {
            id: Date.now().toString(),
            type: 'optimization',
            title: 'Performance Improvement',
            description: 'Consider optimizing this code for better performance',
            code: 'const optimizedVersion = memoize(expensiveFunction);',
            language: data.language,
            confidence: 0.85
          }
        ],
        issues: [
          {
            type: 'warning',
            severity: 'medium',
            message: 'Potential performance issue detected',
            line: 42
          }
        ]
      }
    };
  }

  // Health check
  async getHealth(): Promise<ApiResponse> {
    await this.delay(100);
    return {
      success: true,
      data: {
        status: 'healthy',
        timestamp: new Date().toISOString(),
        version: '1.0.0-mock',
        environment: 'development'
      }
    };
  }

  // Helper method to simulate network delay
  private async delay(ms: number = MOCK_DELAY): Promise<void> {
    return new Promise(resolve => {
      // Randomize the delay slightly for more realistic behavior
      const jitter = Math.floor(Math.random() * 100);
      setTimeout(resolve, ms + jitter);
    });
  }
}

export default new MockApiService();